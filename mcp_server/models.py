# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T12:17:08+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint


class BasicAuthCredentials(BaseModel):
    password: str
    username: str


class Request(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type(Enum):
    lognormal = 'lognormal'


class DelayDistribution(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type] = None


class Type1(Enum):
    uniform = 'uniform'


class DelayDistribution1(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type1] = None
    upper: Optional[int] = None


class Fault(Enum):
    CONNECTION_RESET_BY_PEER = 'CONNECTION_RESET_BY_PEER'
    EMPTY_RESPONSE = 'EMPTY_RESPONSE'
    MALFORMED_RESPONSE_CHUNK = 'MALFORMED_RESPONSE_CHUNK'
    RANDOM_DATA_THEN_CLOSE = 'RANDOM_DATA_THEN_CLOSE'


class Response(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution, DelayDistribution1]] = Field(
        None,
        description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class Mapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class Meta(BaseModel):
    total: int = Field(..., examples=[4])


class FieldAdminMappingsGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: Optional[List[Mapping]] = None
    meta: Optional[Meta] = None


class Request1(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type2(Enum):
    lognormal = 'lognormal'


class DelayDistribution2(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type2] = None


class Type3(Enum):
    uniform = 'uniform'


class DelayDistribution3(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type3] = None
    upper: Optional[int] = None


class Response1(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution2, DelayDistribution3]] = Field(
        None,
        description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class FieldAdminMappingsPostRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request1] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response1] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class Request2(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type4(Enum):
    lognormal = 'lognormal'


class DelayDistribution4(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type4] = None


class Type5(Enum):
    uniform = 'uniform'


class DelayDistribution5(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type5] = None
    upper: Optional[int] = None


class Response2(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution4, DelayDistribution5]] = Field(
        None,
        description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class FieldAdminMappingsPostResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request2] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response2] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class FieldAdminMappingsFindByMetadataPostRequest1(BaseModel):
    caseInsensitive: Optional[bool] = None
    equalTo: bool


class FieldAdminMappingsFindByMetadataPostRequest2(BaseModel):
    contains: str


class FieldAdminMappingsFindByMetadataPostRequest3(BaseModel):
    matches: str


class FieldAdminMappingsFindByMetadataPostRequest4(BaseModel):
    doesNotMatch: str


class FieldAdminMappingsFindByMetadataPostRequest5(BaseModel):
    equalToJson: str


class FieldAdminMappingsFindByMetadataPostRequest6(BaseModel):
    ignoreArrayOrder: Optional[bool] = None
    ignoreExtraElements: Optional[bool] = None
    matchesJsonPath: str


class FieldAdminMappingsFindByMetadataPostRequest7(BaseModel):
    equalToXml: str


class FieldAdminMappingsFindByMetadataPostRequest8(BaseModel):
    matchesXpath: str
    namespaces: Optional[Dict[str, Any]] = None
    valuePattern: Optional[Dict[str, Any]] = None


class FieldAdminMappingsFindByMetadataPostRequest(
    RootModel[
        Union[
            FieldAdminMappingsFindByMetadataPostRequest1,
            FieldAdminMappingsFindByMetadataPostRequest2,
            FieldAdminMappingsFindByMetadataPostRequest3,
            FieldAdminMappingsFindByMetadataPostRequest4,
            FieldAdminMappingsFindByMetadataPostRequest5,
            FieldAdminMappingsFindByMetadataPostRequest6,
            FieldAdminMappingsFindByMetadataPostRequest7,
            FieldAdminMappingsFindByMetadataPostRequest8,
        ]
    ]
):
    root: Union[
        FieldAdminMappingsFindByMetadataPostRequest1,
        FieldAdminMappingsFindByMetadataPostRequest2,
        FieldAdminMappingsFindByMetadataPostRequest3,
        FieldAdminMappingsFindByMetadataPostRequest4,
        FieldAdminMappingsFindByMetadataPostRequest5,
        FieldAdminMappingsFindByMetadataPostRequest6,
        FieldAdminMappingsFindByMetadataPostRequest7,
        FieldAdminMappingsFindByMetadataPostRequest8,
    ]


class Request3(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type6(Enum):
    lognormal = 'lognormal'


class DelayDistribution6(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type6] = None


class Type7(Enum):
    uniform = 'uniform'


class DelayDistribution7(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type7] = None
    upper: Optional[int] = None


class Response3(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution6, DelayDistribution7]] = Field(
        None,
        description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class Mapping1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request3] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response3] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class FieldAdminMappingsFindByMetadataPostResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: Optional[List[Mapping1]] = None
    meta: Optional[Meta] = None


class FieldAdminMappingsRemoveByMetadataPostRequest1(BaseModel):
    caseInsensitive: Optional[bool] = None
    equalTo: bool


class FieldAdminMappingsRemoveByMetadataPostRequest2(BaseModel):
    contains: str


class FieldAdminMappingsRemoveByMetadataPostRequest3(BaseModel):
    matches: str


class FieldAdminMappingsRemoveByMetadataPostRequest4(BaseModel):
    doesNotMatch: str


class FieldAdminMappingsRemoveByMetadataPostRequest5(BaseModel):
    equalToJson: str


class FieldAdminMappingsRemoveByMetadataPostRequest6(BaseModel):
    ignoreArrayOrder: Optional[bool] = None
    ignoreExtraElements: Optional[bool] = None
    matchesJsonPath: str


class FieldAdminMappingsRemoveByMetadataPostRequest7(BaseModel):
    equalToXml: str


class FieldAdminMappingsRemoveByMetadataPostRequest8(BaseModel):
    matchesXpath: str
    namespaces: Optional[Dict[str, Any]] = None
    valuePattern: Optional[Dict[str, Any]] = None


class FieldAdminMappingsRemoveByMetadataPostRequest(
    RootModel[
        Union[
            FieldAdminMappingsRemoveByMetadataPostRequest1,
            FieldAdminMappingsRemoveByMetadataPostRequest2,
            FieldAdminMappingsRemoveByMetadataPostRequest3,
            FieldAdminMappingsRemoveByMetadataPostRequest4,
            FieldAdminMappingsRemoveByMetadataPostRequest5,
            FieldAdminMappingsRemoveByMetadataPostRequest6,
            FieldAdminMappingsRemoveByMetadataPostRequest7,
            FieldAdminMappingsRemoveByMetadataPostRequest8,
        ]
    ]
):
    root: Union[
        FieldAdminMappingsRemoveByMetadataPostRequest1,
        FieldAdminMappingsRemoveByMetadataPostRequest2,
        FieldAdminMappingsRemoveByMetadataPostRequest3,
        FieldAdminMappingsRemoveByMetadataPostRequest4,
        FieldAdminMappingsRemoveByMetadataPostRequest5,
        FieldAdminMappingsRemoveByMetadataPostRequest6,
        FieldAdminMappingsRemoveByMetadataPostRequest7,
        FieldAdminMappingsRemoveByMetadataPostRequest8,
    ]


class Request4(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type8(Enum):
    lognormal = 'lognormal'


class DelayDistribution8(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type8] = None


class Type9(Enum):
    uniform = 'uniform'


class DelayDistribution9(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type9] = None
    upper: Optional[int] = None


class Response4(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution8, DelayDistribution9]] = Field(
        None,
        description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class FieldAdminMappingsStubMappingIdGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request4] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response4] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class Request5(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type10(Enum):
    lognormal = 'lognormal'


class DelayDistribution10(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type10] = None


class Type11(Enum):
    uniform = 'uniform'


class DelayDistribution11(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type11] = None
    upper: Optional[int] = None


class Response5(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution10, DelayDistribution11]] = (
        Field(
            None,
            description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
        )
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class FieldAdminMappingsStubMappingIdPutRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request5] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response5] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class Request6(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type12(Enum):
    lognormal = 'lognormal'


class DelayDistribution12(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type12] = None


class Type13(Enum):
    uniform = 'uniform'


class DelayDistribution13(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type13] = None
    upper: Optional[int] = None


class Response6(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution12, DelayDistribution13]] = (
        Field(
            None,
            description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
        )
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class FieldAdminMappingsStubMappingIdPutResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request6] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response6] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class FieldAdminNearMissesRequestPostRequest(BaseModel):
    absoluteUrl: Optional[str] = Field(
        None,
        description='The full URL to match against',
        examples=['http://localhost:56738/received-request/2'],
    )
    body: Optional[str] = Field(
        None, description='Body string to match against', examples=['Hello world']
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
        examples=[{}],
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
        examples=[
            {
                'Connection': 'keep-alive',
                'Host': 'localhost:56738',
                'User-Agent': 'Apache-HttpClient/4.5.1 (Java/1.7.0_51)',
            }
        ],
    )
    method: Optional[str] = Field(
        None, description='The HTTP request method', examples=['GET']
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against',
        examples=['/received-request/2'],
    )


class NearMiss(BaseModel):
    absoluteUrl: Optional[str] = Field(
        None,
        description='The full URL to match against',
        examples=['http://localhost:56738/received-request/2'],
    )
    body: Optional[str] = Field(
        None, description='Body string to match against', examples=['Hello world']
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
        examples=[{}],
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
        examples=[
            {
                'Connection': 'keep-alive',
                'Host': 'localhost:56738',
                'User-Agent': 'Apache-HttpClient/4.5.1 (Java/1.7.0_51)',
            }
        ],
    )
    method: Optional[str] = Field(
        None, description='The HTTP request method', examples=['GET']
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against',
        examples=['/received-request/2'],
    )


class FieldAdminNearMissesRequestPostResponse(BaseModel):
    nearMisses: Optional[List[NearMiss]] = None


class FieldAdminNearMissesRequestPatternPostRequest(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminNearMissesRequestPatternPostResponse(BaseModel):
    nearMisses: Optional[List[NearMiss]] = None


class CaptureHeaders(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    caseInsensitive: Optional[bool] = None


class ExtractBodyCriteria(BaseModel):
    binarySizeThreshold: Optional[str] = Field(
        '0',
        description='Size threshold for extracting binary response bodies. Supports humanized size strings, e.g. "56 Mb". Default unit is bytes.',
        examples=['18.2 GB'],
    )
    textSizeThreshold: Optional[str] = Field(
        '0',
        description='Size threshold for extracting binary response bodies. Supports humanized size strings, e.g. "56 Mb". Default unit is bytes.',
        examples=['18.2 GB'],
    )


class Matcher(Enum):
    auto = 'auto'


class RequestBodyPattern(BaseModel):
    caseInsensitive: Optional[bool] = Field(
        False,
        description='If equalTo is used, match body use case-insensitive string comparison',
    )
    ignoreArrayOrder: Optional[bool] = Field(
        True, description='If equalToJson is used, ignore order of array elements'
    )
    ignoreExtraElements: Optional[bool] = Field(
        True,
        description='If equalToJson is used, matcher ignores extra elements in objects',
    )
    matcher: Optional[Matcher] = None


class Matcher1(Enum):
    equalTo = 'equalTo'


class RequestBodyPattern1(BaseModel):
    caseInsensitive: Optional[bool] = Field(
        False, description='Match body using case-insensitive string comparison'
    )
    matcher: Optional[Matcher1] = None


class Matcher2(Enum):
    equalToJson = 'equalToJson'


class RequestBodyPattern2(BaseModel):
    ignoreArrayOrder: Optional[bool] = Field(
        True, description='Ignore order of array elements'
    )
    ignoreExtraElements: Optional[bool] = Field(
        True, description='Ignore extra elements in objects'
    )
    matcher: Optional[Matcher2] = None


class Matcher3(Enum):
    equalToXml = 'equalToXml'


class RequestBodyPattern3(BaseModel):
    matcher: Optional[Matcher3] = None


class Filters(BaseModel):
    ids: Optional[List[str]] = None
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminRecordingsSnapshotPostRequest(BaseModel):
    captureHeaders: Optional[Dict[str, CaptureHeaders]] = Field(
        None,
        description='Headers from the request to include in the generated stub mappings, mapped to parameter objects. The only parameter available is "caseInsensitive", which defaults to false',
        examples=[{'Accept': {}, 'Content-Type': {'caseInsensitive': True}}],
    )
    extractBodyCriteria: Optional[ExtractBodyCriteria] = Field(
        None,
        description='Criteria for extracting response bodies to a separate file instead of including it in the stub mapping',
        examples=[[{'binarySizeThreshold': '1 Mb', 'textSizeThreshold': '2 kb'}]],
    )
    persist: Optional[bool] = Field(
        True,
        description='Whether to save stub mappings to the file system or just return them',
    )
    repeatsAsScenarios: Optional[bool] = Field(
        True,
        description='When true, duplicate requests will be added to a Scenario. When false, duplicates are discarded',
    )
    requestBodyPattern: Optional[
        Union[
            RequestBodyPattern,
            RequestBodyPattern1,
            RequestBodyPattern2,
            RequestBodyPattern3,
        ]
    ] = Field(
        None,
        description='Control the request body matcher used in generated stub mappings',
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='List of names of stub mappings transformers to apply to generated stubs',
    )
    transformers: Optional[List[str]] = Field(
        None, description='Parameters to pass to stub mapping transformers'
    )
    filters: Optional[Filters] = None


class Request7(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type14(Enum):
    lognormal = 'lognormal'


class DelayDistribution14(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type14] = None


class Type15(Enum):
    uniform = 'uniform'


class DelayDistribution15(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type15] = None
    upper: Optional[int] = None


class Response7(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution14, DelayDistribution15]] = (
        Field(
            None,
            description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
        )
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class Mapping2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request7] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response7] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class FieldAdminRecordingsSnapshotPostResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: Optional[List[Mapping2]] = None
    meta: Optional[Meta] = None


class Matcher4(Enum):
    auto = 'auto'


class RequestBodyPattern4(BaseModel):
    caseInsensitive: Optional[bool] = Field(
        False,
        description='If equalTo is used, match body use case-insensitive string comparison',
    )
    ignoreArrayOrder: Optional[bool] = Field(
        True, description='If equalToJson is used, ignore order of array elements'
    )
    ignoreExtraElements: Optional[bool] = Field(
        True,
        description='If equalToJson is used, matcher ignores extra elements in objects',
    )
    matcher: Optional[Matcher4] = None


class Matcher5(Enum):
    equalTo = 'equalTo'


class RequestBodyPattern5(BaseModel):
    caseInsensitive: Optional[bool] = Field(
        False, description='Match body using case-insensitive string comparison'
    )
    matcher: Optional[Matcher5] = None


class Matcher6(Enum):
    equalToJson = 'equalToJson'


class RequestBodyPattern6(BaseModel):
    ignoreArrayOrder: Optional[bool] = Field(
        True, description='Ignore order of array elements'
    )
    ignoreExtraElements: Optional[bool] = Field(
        True, description='Ignore extra elements in objects'
    )
    matcher: Optional[Matcher6] = None


class Matcher7(Enum):
    equalToXml = 'equalToXml'


class RequestBodyPattern7(BaseModel):
    matcher: Optional[Matcher7] = None


class Filters1(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminRecordingsStartPostRequest(BaseModel):
    captureHeaders: Optional[Dict[str, CaptureHeaders]] = Field(
        None,
        description='Headers from the request to include in the generated stub mappings, mapped to parameter objects. The only parameter available is "caseInsensitive", which defaults to false',
        examples=[{'Accept': {}, 'Content-Type': {'caseInsensitive': True}}],
    )
    extractBodyCriteria: Optional[ExtractBodyCriteria] = Field(
        None,
        description='Criteria for extracting response bodies to a separate file instead of including it in the stub mapping',
        examples=[[{'binarySizeThreshold': '1 Mb', 'textSizeThreshold': '2 kb'}]],
    )
    persist: Optional[bool] = Field(
        True,
        description='Whether to save stub mappings to the file system or just return them',
    )
    repeatsAsScenarios: Optional[bool] = Field(
        True,
        description='When true, duplicate requests will be added to a Scenario. When false, duplicates are discarded',
    )
    requestBodyPattern: Optional[
        Union[
            RequestBodyPattern4,
            RequestBodyPattern5,
            RequestBodyPattern6,
            RequestBodyPattern7,
        ]
    ] = Field(
        None,
        description='Control the request body matcher used in generated stub mappings',
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='List of names of stub mappings transformers to apply to generated stubs',
    )
    transformers: Optional[List[str]] = Field(
        None, description='Parameters to pass to stub mapping transformers'
    )
    filters: Optional[Filters1] = None
    targetBaseUrl: Optional[str] = Field(
        None,
        description='Target URL when using the record and playback API',
        examples=['http://example.mocklab.io'],
    )


class Status(Enum):
    NeverStarted = 'NeverStarted'
    Recording = 'Recording'
    Stopped = 'Stopped'


class FieldAdminRecordingsStatusGetResponse(BaseModel):
    status: Optional[Status] = Field(None, examples=['Stopped'])


class Request8(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class Type16(Enum):
    lognormal = 'lognormal'


class DelayDistribution16(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type16] = None


class Type17(Enum):
    uniform = 'uniform'


class DelayDistribution17(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type17] = None
    upper: Optional[int] = None


class Response8(BaseModel):
    additionalProxyRequestHeaders: Optional[Dict[str, Any]] = Field(
        None, description='Extra request headers to send when proxying to another host.'
    )
    base64Body: Optional[str] = Field(
        None,
        description='The response body as a base64 encoded string (useful for binary content). Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    body: Optional[str] = Field(
        None,
        description='The response body as a string. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    bodyFileName: Optional[str] = Field(
        None,
        description='The path to the file containing the response body, relative to the configured file root. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    delayDistribution: Optional[Union[DelayDistribution16, DelayDistribution17]] = (
        Field(
            None,
            description='The delay distribution. Valid property configuration is either median/sigma/type or lower/type/upper.',
        )
    )
    fault: Optional[Fault] = Field(
        None, description='The fault to apply (instead of a full, valid response).'
    )
    fixedDelayMilliseconds: Optional[int] = Field(
        None,
        description='Number of milliseconds to delay be before sending the response.',
    )
    fromConfiguredStub: Optional[bool] = Field(
        None,
        description='Read-only flag indicating false if this was the default, unmatched response. Not present otherwise.',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None, description='Map of response headers to send'
    )
    jsonBody: Optional[Dict[str, Any]] = Field(
        None,
        description='The response body as a JSON object. Only one of body, base64Body, jsonBody or bodyFileName may be specified.',
    )
    proxyBaseUrl: Optional[str] = Field(
        None, description='The base URL of the target to proxy matching requests to.'
    )
    status: Optional[int] = Field(
        None, description='The HTTP status code to be returned'
    )
    statusMessage: Optional[str] = Field(
        None, description='The HTTP status message to be returned'
    )
    transformerParameters: Optional[Dict[str, Any]] = Field(
        None, description='Parameters to apply to response transformers.'
    )
    transformers: Optional[List[str]] = Field(
        None, description='List of names of transformers to apply to this response.'
    )


class Mapping3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description="This stub mapping's unique identifier")
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Arbitrary metadata to be used for e.g. tagging, documentation. Can also be used to find and remove stubs.',
    )
    name: Optional[str] = Field(None, description="The stub mapping's name")
    newScenarioState: Optional[str] = Field(
        None,
        description='The new state for the scenario to be updated to after this stub is served.',
    )
    persistent: Optional[bool] = Field(
        None,
        description='Indicates that the stub mapping should be persisted immediately on create/update/delete and survive resets to default.',
    )
    postServeActions: Optional[Dict[str, Any]] = Field(
        None,
        description='A map of the names of post serve action extensions to trigger and their parameters.',
    )
    priority: Optional[conint(ge=1)] = Field(
        None,
        description="This stub mapping's priority relative to others. 1 is highest.",
    )
    request: Optional[Request8] = Field(
        None,
        examples=[
            {
                'bodyPatterns': [{'equalToJson': '{ "numbers": [1, 2, 3] }'}],
                'headers': {'Content-Type': {'equalTo': 'application/json'}},
                'method': 'POST',
                'url': '/some/thing',
            }
        ],
    )
    requiredScenarioState: Optional[str] = Field(
        None,
        description='The required state of the scenario in order for this stub to be matched.',
    )
    response: Optional[Response8] = None
    scenarioName: Optional[str] = Field(
        None, description='The name of the scenario that this stub mapping is part of'
    )
    uuid: Optional[str] = Field(None, description='Alias for the id')


class FieldAdminRecordingsStopPostResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: Optional[List[Mapping3]] = None
    meta: Optional[Meta] = None


class FieldAdminRequestsCountPostRequest(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminRequestsCountPostResponse(BaseModel):
    count: Optional[int] = Field(None, examples=[4])


class FieldAdminRequestsFindPostRequest(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminRequestsRemovePostRequest(BaseModel):
    basicAuthCredentials: Optional[BasicAuthCredentials] = Field(
        None, description='Pre-emptive basic auth credentials to match against'
    )
    bodyPatterns: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Request body patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    cookies: Optional[Dict[str, Any]] = Field(
        None,
        description='Cookie patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    headers: Optional[Dict[str, Any]] = Field(
        None,
        description='Header patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    method: Optional[str] = Field(None, description='The HTTP request method e.g. GET')
    queryParameters: Optional[Dict[str, Any]] = Field(
        None,
        description='Query parameter patterns to match against in the <key>: { "<predicate>": "<value>" } form',
    )
    url: Optional[str] = Field(
        None,
        description='The path and query to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPath: Optional[str] = Field(
        None,
        description='The path to match exactly against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPathPattern: Optional[str] = Field(
        None,
        description='The path regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )
    urlPattern: Optional[str] = Field(
        None,
        description='The path and query regex to match against. Only one of url, urlPattern, urlPath or urlPathPattern may be specified.',
    )


class FieldAdminRequestsRemoveByMetadataPostRequest1(BaseModel):
    caseInsensitive: Optional[bool] = None
    equalTo: bool


class FieldAdminRequestsRemoveByMetadataPostRequest2(BaseModel):
    contains: str


class FieldAdminRequestsRemoveByMetadataPostRequest3(BaseModel):
    matches: str


class FieldAdminRequestsRemoveByMetadataPostRequest4(BaseModel):
    doesNotMatch: str


class FieldAdminRequestsRemoveByMetadataPostRequest5(BaseModel):
    equalToJson: str


class FieldAdminRequestsRemoveByMetadataPostRequest6(BaseModel):
    ignoreArrayOrder: Optional[bool] = None
    ignoreExtraElements: Optional[bool] = None
    matchesJsonPath: str


class FieldAdminRequestsRemoveByMetadataPostRequest7(BaseModel):
    equalToXml: str


class FieldAdminRequestsRemoveByMetadataPostRequest8(BaseModel):
    matchesXpath: str
    namespaces: Optional[Dict[str, Any]] = None
    valuePattern: Optional[Dict[str, Any]] = None


class FieldAdminRequestsRemoveByMetadataPostRequest(
    RootModel[
        Union[
            FieldAdminRequestsRemoveByMetadataPostRequest1,
            FieldAdminRequestsRemoveByMetadataPostRequest2,
            FieldAdminRequestsRemoveByMetadataPostRequest3,
            FieldAdminRequestsRemoveByMetadataPostRequest4,
            FieldAdminRequestsRemoveByMetadataPostRequest5,
            FieldAdminRequestsRemoveByMetadataPostRequest6,
            FieldAdminRequestsRemoveByMetadataPostRequest7,
            FieldAdminRequestsRemoveByMetadataPostRequest8,
        ]
    ]
):
    root: Union[
        FieldAdminRequestsRemoveByMetadataPostRequest1,
        FieldAdminRequestsRemoveByMetadataPostRequest2,
        FieldAdminRequestsRemoveByMetadataPostRequest3,
        FieldAdminRequestsRemoveByMetadataPostRequest4,
        FieldAdminRequestsRemoveByMetadataPostRequest5,
        FieldAdminRequestsRemoveByMetadataPostRequest6,
        FieldAdminRequestsRemoveByMetadataPostRequest7,
        FieldAdminRequestsRemoveByMetadataPostRequest8,
    ]


class FieldAdminRequestsUnmatchedNearMissesGetResponse(BaseModel):
    nearMisses: Optional[List[NearMiss]] = None


class Scenario(BaseModel):
    id: Optional[str] = Field(
        None,
        description='The scenario ID',
        examples=['c8d249ec-d86d-48b1-88a8-a660e6848042'],
    )
    name: Optional[str] = Field(
        None, description='The scenario name', examples=['my_scenario']
    )
    possibleStates: Optional[List[str]] = Field(
        None, examples=[['Started', 'state_1', 'state_2']]
    )
    state: Optional[str] = Field(
        'Started',
        description='The current state of this scenario',
        examples=['state_2'],
    )


class FieldAdminScenariosGetResponse(BaseModel):
    scenarios: Optional[List[Scenario]] = None


class Type18(Enum):
    lognormal = 'lognormal'


class FieldAdminSettingsPostRequest1(BaseModel):
    median: Optional[int] = None
    sigma: Optional[float] = None
    type: Optional[Type18] = None


class Type19(Enum):
    uniform = 'uniform'


class FieldAdminSettingsPostRequest2(BaseModel):
    lower: Optional[int] = None
    type: Optional[Type19] = None
    upper: Optional[int] = None


class FieldAdminSettingsPostRequest3(BaseModel):
    fixedDelay: Optional[float] = None


class FieldAdminSettingsPostRequest4(
    FieldAdminSettingsPostRequest1, FieldAdminSettingsPostRequest3
):
    pass


class FieldAdminSettingsPostRequest5(
    FieldAdminSettingsPostRequest2, FieldAdminSettingsPostRequest3
):
    pass


class FieldAdminSettingsPostRequest(
    RootModel[Union[FieldAdminSettingsPostRequest4, FieldAdminSettingsPostRequest5]]
):
    root: Union[FieldAdminSettingsPostRequest4, FieldAdminSettingsPostRequest5]
